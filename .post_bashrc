#!/usr/bin/env bash

# Prevent double-sourcing
if [[ -n "${__POST_BASHRC_LOADED:-}" ]]; then return 0; fi
__POST_BASHRC_LOADED=1

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Environment variables
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
set_post_bashrc_environment() {
    set -a

    local env_file="$HOME/.env"

    # shellcheck source=/dev/null
    if [ -f "$env_file" ]; then
        source "$env_file"
    else
        echo "Missing .env file"
        return 1
    fi

    NVM_DIR="$HOME/.nvm"

    IS_WSL=false
    if grep -qi microsoft /proc/version; then
        IS_WSL=true
    fi

    if [ "$IS_WSL" = true ]; then
        if command -v cmd.exe >/dev/null 2>&1; then
            WINDOWS_USER=$(cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r')
        else
            WINDOWS_USER=""
        fi
        VSCODE_SETTINGS_DIR="/mnt/c/Users/$WINDOWS_USER/AppData/Roaming/Code/User"
    else
        VSCODE_SETTINGS_DIR="$HOME/.config/Code/User"
    fi

    # ignore unused variable
    # shellcheck disable=SC2034
    VSCODE_SETTINGS_FILE="$VSCODE_SETTINGS_DIR/settings.json"

    if declare -p GITHUB_PARENT &>/dev/null; then
        # shellcheck disable=SC2034
        VSCODE_WORKSPACE_DIR="$GITHUB_PARENT/my-vs-code/workspaces"
        # shellcheck disable=SC2034
        GITHUB_DOTFILES_DIR="$GITHUB_PARENT/dotfiles"
    else
        echo "âš ï¸ GITHUB_PARENT not set"
    fi

    local symlinks_dir="$HOME/.symlinks"
    SYMLINKS_BIN_DIR="$symlinks_dir/bin"
    SYMLINKS_SOURCE_DIR="$symlinks_dir/source"

    set +a
}

if declare -F set_post_bashrc_environment >/dev/null; then
    if ! set_post_bashrc_environment; then
        echo "âŒ Environment setup failed"
        return 1
    fi
else
    echo "âš ï¸  set_post_bashrc_environment is not defined"
    return 1
fi

source_bash_functions() {
    if [[ -n "${SYMLINKS_SOURCE_DIR:-}" ]]; then
        local bf_file="$SYMLINKS_SOURCE_DIR/bash_functions"

        if [ -f "$bf_file" ]; then
            # shellcheck source=/dev/null
            source "$bf_file"
        else
            echo "âš ï¸ Missing file: $bf_file"
        fi
    else
        echo "âš ï¸ SYMLINKS_SOURCE_DIR not set â€“ skipping bash_functions"
    fi
}
source_bash_functions

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Utility functions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

finish_dotfile_test() {
    local name="$1"
    local sources=("${BASH_SOURCE[@]:1}") # Skip this function itself
    echo -e "finish_dotfile_test started at: $(date)"
    (
        IFS=' '
        echo "This script           : ${sources[0]}"
    )
    echo -e "\$name=$name"
    echo -e "\$TEST_DOTFILE_NAME=$TEST_DOTFILE_NAME"
    echo -e "finish_dotfile_test finished at: $(date)"
    if [[ "$name" == "$TEST_DOTFILE_NAME" ]]; then
        echo -e "ğŸ›‘ Exiting"
        exit
    fi
}

# Map of verified safe local commands
declare -A _RUN_LOCAL_SAFE_CACHE=()

run_local() {
    local cmd="$1"
    shift
    local local_cmd="$SYMLINKS_BIN_DIR/$cmd"

    # Check cache first
    if [[ "${_RUN_LOCAL_SAFE_CACHE[$cmd]-}" == "safe" ]]; then
        "$local_cmd" "$@" || {
            echo "âš ï¸ Command '$cmd' failed. Skipping." >&2
            return 0
        }
        return 0
    fi

    # First-time check
    if [ ! -x "$local_cmd" ]; then
        echo "âš ï¸ Command '$cmd' not found or not executable in $SYMLINKS_BIN_DIR. Skipping." >&2
        _RUN_LOCAL_SAFE_CACHE["$cmd"]="missing"
        return 0
    fi

    local resolved
    resolved="$(command -v "$cmd" 2>/dev/null || true)"
    if [ "$resolved" != "$local_cmd" ]; then
        echo "âš ï¸ Command '$cmd' is not resolved to $SYMLINKS_BIN_DIR first in PATH (resolved to $resolved). Skipping." >&2
        _RUN_LOCAL_SAFE_CACHE["$cmd"]="wrong_path"
        return 0
    fi

    # Safe â†’ cache this fact
    _RUN_LOCAL_SAFE_CACHE["$cmd"]="safe"
    "$local_cmd" "$@" || {
        echo "âš ï¸ Command '$cmd' failed. Skipping." >&2
        return 0
    }
}

start_dotfile_test() {
    echo "start_dotfile_test started at: $(date)"

    echo -e "\$TEST_DOTFILE_NAME=$TEST_DOTFILE_NAME"

    local sources=("${BASH_SOURCE[@]:1}") # Skip this function itself

    echo "Shell type           : $0"
    echo "Bash version         : $BASH_VERSION"
    (
        IFS=' '
        echo "Call stack           : ${sources[*]}"
    )
    echo "Current options (\$-): $-"

    echo -n "Is interactive?      : [[ \$- == *i* ]] â†’ "
    [[ $- == *i* ]] && echo yes || echo no

    echo -n "Is login shell?      : shopt -q login_shell â†’ "
    shopt -q login_shell && echo yes || echo no

    echo -n "PS1 set?             : declare -p PS1 &>/dev/null â†’ "
    declare -p PS1 &>/dev/null && echo yes || echo no

    echo "TERM_PROGRAM         : ${TERM_PROGRAM:-}"
    echo "Host                 : $(hostname -f 2>/dev/null || hostname)"
    echo "Shell PID            : $$"

    # More portable parent process command
    local parent_pid parent_cmd
    parent_pid=$(ps -o ppid= -p $$ 2>/dev/null)
    parent_cmd=$(ps -o comm= -p "$parent_pid" 2>/dev/null || echo unknown)
    echo "Parent process       : ${parent_cmd}"

    echo "TTY                  : $(tty 2>/dev/null || echo not-a-tty)"

    echo -e "\n--- Environment Variables ---"
    env | sort
    echo -e "\n--- Aliases ---"
    alias
    echo -e "\n--- Functions ---"
    compgen -A function
    echo -e "\n--- start_dotfile_test finished at: $(date)\n"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Completions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

complete -F _vcode_autocomplete vcode

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# PATH
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

remove_path "/usr/games"
remove_path "/usr/local/games"

# before

add_path_if_exists before "$SYMLINKS_BIN_DIR"

#after

# go used for hugo
add_path_if_exists after \
    "/mnt/c/Program Files/Microsoft VS Code/bin" \
    "/usr/local/go/bin" \
    "$HOME/go/bin"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Aliases
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if [[ $- == *i* ]]; then
    # We are in an interactive shell
    alias test_bash_functions='source "$HOME/.symlinks/source/test_bash_functions" &>/tmp/test_bash_functions.log'
    alias testlogin='ssh -i ~/.ssh/id_ed25519_testuser testuser@localhost'
fi

declare -p TEST_DOTFILE_NAME &>/dev/null && start_dotfile_test && finish_dotfile_test post_bashrc
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ§  Bash History Cheat Sheet â€“ Rerun & Edit Previous Commands
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ” Rerun Commands
#   !!             â†’ Rerun last command
#   !n             â†’ Run command number n from `history`
#   !string        â†’ Rerun last command starting with 'string'
#   !^             â†’ First argument of previous command
#   !$             â†’ Last argument of previous command

# âœï¸ Modify and Reuse
#   ^old^new       â†’ Replace first 'old' with 'new' in previous command
#   !!:s/old/new/  â†’ Replace first 'old' with 'new'
#   !!:gs/old/new/ â†’ Replace all 'old' with 'new'
#   !n:p           â†’ Print command n without running it
#   fc             â†’ Edit previous command in $EDITOR

# ğŸ” History Search
#   Ctrl + r       â†’ Reverse incremental search
#   Ctrl + s       â†’ Forward search (may need `stty -ixon`)
#   Ctrl + g       â†’ Cancel search
#   Esc            â†’ Drop into prompt with matched command

# ğŸ§ª Example
#   $ echo hellp
#   $ ^hellp^hello   â†’ Corrects and reruns as: echo hello
#   $ !ls            â†’ Repeats last command starting with 'ls'

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
