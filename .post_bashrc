#!/bin/bash

# -----------------------------------------------------------
# Shell strict mode for scripts â€” do not apply to interactive shells
# -----------------------------------------------------------
if [[ $- != *i* ]]; then
    # We are in a non-interactive shell (likely a script)
    set -euo pipefail
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Utility functions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

add_path_if_exists() {
    local position="$1" dir="$2"
    if [ -d "$dir" ] && [[ ":$PATH:" != *":$dir:"* ]]; then
        case "$position" in
        before) PATH="$dir:$PATH" ;;
        after) PATH="$PATH:$dir" ;;
        *) echo "Invalid position: $position (use 'before' or 'after')" >&2 ;;
        esac
    fi
}

finish_dotfile_test() {
    local name="$1"
    local sources=("${BASH_SOURCE[@]:1}")  # Skip this function itself
    echo -e "finish_dotfile_test started at: $(date)"
    (IFS=' '; echo "This script           : ${sources[0]}")
    echo -e "\$name=$name"
    echo -e "\$TEST_DOTFILE_NAME=$TEST_DOTFILE_NAME"
    echo -e "finish_dotfile_test finished at: $(date)"
    if [[ "$name" == "$TEST_DOTFILE_NAME" ]]; then
        echo -e "ğŸ›‘ Exiting"
        exit
    fi
}

# Detect if we're being run as part of VS Code's userEnvProbe
is_user_env_probe() {
    ps -eo pid,ppid,args | awk '
        NR > 1 {
            pid[$1] = $2
            cmd[$1] = substr($0, index($0,$3))
        }
        END {
            p = ENVIRON["PPID"]
            while (p > 1) {
                if (cmd[p] ~ /userEnvProbe/) exit 0
                p = pid[p]
            }
            exit 1
        }
    '
}

# Lazy-load nvm (significant speed improvement)
nvm() {
    unset -f nvm
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    nvm "$@"
}

# Map of verified safe local commands
declare -A _RUN_LOCAL_SAFE_CACHE=()

run_local() {
    local cmd="$1"
    shift
    local local_cmd="$HOME/.local/bin/$cmd"

    # Check cache first
    if [[ "${_RUN_LOCAL_SAFE_CACHE[$cmd]-}" == "safe" ]]; then
        "$local_cmd" "$@" || {
            echo "âš ï¸ Command '$cmd' failed. Skipping." >&2
            return 0
        }
        return 0
    fi

    # First-time check
    if [ ! -x "$local_cmd" ]; then
        echo "âš ï¸ Command '$cmd' not found or not executable in $HOME/.local/bin. Skipping." >&2
        _RUN_LOCAL_SAFE_CACHE["$cmd"]="missing"
        return 0
    fi

    local resolved
    resolved="$(command -v "$cmd" 2>/dev/null || true)"
    if [ "$resolved" != "$local_cmd" ]; then
        echo "âš ï¸ Command '$cmd' is not resolved to $HOME/.local/bin first in PATH (resolved to $resolved). Skipping." >&2
        _RUN_LOCAL_SAFE_CACHE["$cmd"]="wrong_path"
        return 0
    fi

    # Safe â†’ cache this fact
    _RUN_LOCAL_SAFE_CACHE["$cmd"]="safe"
    "$local_cmd" "$@" || {
        echo "âš ï¸ Command '$cmd' failed. Skipping." >&2
        return 0
    }
}

start_dotfile_test() {
    echo "start_dotfile_test started at: $(date)"
    
    echo -e "\$TEST_DOTFILE_NAME=$TEST_DOTFILE_NAME"
    
    local sources=("${BASH_SOURCE[@]:1}")  # Skip this function itself

    echo "Shell type           : $0"
    echo "Bash version         : $BASH_VERSION"
    (IFS=' '; echo "Call stack           : ${sources[*]}")
    echo "Current options (\$-): $-"

    echo -n "Is interactive?      : [[ \$- == *i* ]] â†’ "
    [[ $- == *i* ]] && echo yes || echo no

    echo -n "Is login shell?      : shopt -q login_shell â†’ "
    shopt -q login_shell && echo yes || echo no

    echo -n "PS1 set?             : declare -p PS1 &>/dev/null â†’ "
    declare -p PS1 &>/dev/null && echo yes || echo no

    echo "TERM_PROGRAM         : ${TERM_PROGRAM:-}"
    echo "Host                 : $(hostname -f 2>/dev/null || hostname)"
    echo "Shell PID            : $$"


    # More portable parent process command
    local parent_pid parent_cmd
    parent_pid=$(ps -o ppid= -p $$ 2>/dev/null)
    parent_cmd=$(ps -o comm= -p "$parent_pid" 2>/dev/null || echo unknown)
    echo "Parent process       : ${parent_cmd}"

    echo "TTY                  : $(tty 2>/dev/null || echo not-a-tty)"

    echo -e "\n--- Environment Variables ---"
    env | sort
    echo -e "\n--- Aliases ---"
    alias
    echo -e "\n--- Functions ---"
    compgen -A function
    echo -e "\n--- start_dotfile_test finished at: $(date)\n"
}

source_if_exists() {
    local file="$1"
    if [ -f "$file" ]; then
        # shellcheck source=/dev/null
        source "$file"
    fi
}

vcode() {
    local base_dir="${HOME}/projects"

    if [[ $# -eq 0 ]]; then
        echo "Usage: vcode [project1 project2 ...] or vcode --all"
        return 0
    fi

    if [[ $# -eq 1 && -f "${base_dir}/$1.code-workspace" ]]; then
        # Use existing named workspace file
        code "${base_dir}/$1.code-workspace"
        return 0
    fi

    # Else, build a temporary workspace file
    local tmp_workspace_dir="/tmp/vcode_workspace_$$"
    mkdir -p "$tmp_workspace_dir"
    local workspace_file="${tmp_workspace_dir}/workspace.code-workspace"

    local folders=()

    if [[ "$1" == "--all" ]]; then
        # Include all immediate subdirectories of ~/projects/
        while IFS= read -r -d '' dir; do
            folders+=("{\"path\": \"$dir\"}")
        done < <(find "$base_dir" -mindepth 1 -maxdepth 1 -type d -print0)

        if [[ ${#folders[@]} -eq 0 ]]; then
            echo "âš ï¸ No subdirectories found under $base_dir"
            return 0
        fi
    else
        # Manually specified projects
        for project in "$@"; do
            local dir="$base_dir/$project"
            if [[ ! -d "$dir" ]]; then
                echo "âŒ '$project' does not exist in $base_dir"
                continue
            fi
            folders+=("{\"path\": \"$dir\"}")
        done

        if [[ ${#folders[@]} -eq 0 ]]; then
            echo "ğŸš« No valid projects to open"
            return 0
        fi
    fi

    # Write workspace JSON
    printf '{\n  "folders": [\n    %s\n  ]\n}\n' "$(
        IFS=,$'\n'
        echo "${folders[*]}"
    )" >"$workspace_file"

    code "$workspace_file"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Completions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_vcode_autocomplete() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local project_dir="$HOME/projects"
    local projects

    # Only complete if not using --all
    if [[ "$COMP_CWORD" -ge 1 && "${COMP_WORDS[1]}" != --all ]]; then
        projects=$(find "$project_dir" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' 2>/dev/null)
        readarray -t COMPREPLY < <(compgen -W "$projects" -- "$cur")
    fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Environment variables
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

set -a

NVM_DIR="$HOME/.nvm"

IS_WSL=false
if grep -qi microsoft /proc/version; then
    IS_WSL=true
fi

if [ "$IS_WSL" = true ]; then
    if command -v cmd.exe >/dev/null 2>&1; then
        WINDOWS_USER=$(cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r')
    else
        WINDOWS_USER=""
    fi
    VSCODE_SETTINGS_DIR="/mnt/c/Users/$WINDOWS_USER/AppData/Roaming/Code/User"
else
    VSCODE_SETTINGS_DIR="$HOME/.config/Code/User"
fi

# ignore unused variable
# shellcheck disable=SC2034
VSCODE_SETTINGS_FILE="$VSCODE_SETTINGS_DIR/settings.json"

source_if_exists "$HOME/.env"

set +a

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Execute commands
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

complete -F _vcode_autocomplete vcode

add_path_if_exists before "$HOME/.local/bin"

# go used for hugo
add_path_if_exists after "/usr/local/go/bin"
add_path_if_exists after "$HOME/go/bin"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Aliases
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if [[ $- == *i* ]]; then
    # We are in an interactive shell
    alias codehugo='code --profile "hugo-blog" ${GITHUB_PARENT}/hugo-blog.code-workspace'
    alias codefin='code --profile "python-project" ${GITHUB_PARENT}/our-finances.code-workspace'
    alias codepy='code --profile "python-projects"'
    alias testlogin='ssh -i ~/.ssh/id_ed25519_testuser testuser@localhost'
fi

declare -p TEST_DOTFILE_NAME &>/dev/null && start_dotfile_test && finish_dotfile_test post_bashrc
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ§  Bash History Cheat Sheet â€“ Rerun & Edit Previous Commands
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ” Rerun Commands
#   !!             â†’ Rerun last command
#   !n             â†’ Run command number n from `history`
#   !string        â†’ Rerun last command starting with 'string'
#   !^             â†’ First argument of previous command
#   !$             â†’ Last argument of previous command

# âœï¸ Modify and Reuse
#   ^old^new       â†’ Replace first 'old' with 'new' in previous command
#   !!:s/old/new/  â†’ Replace first 'old' with 'new'
#   !!:gs/old/new/ â†’ Replace all 'old' with 'new'
#   !n:p           â†’ Print command n without running it
#   fc             â†’ Edit previous command in $EDITOR

# ğŸ” History Search
#   Ctrl + r       â†’ Reverse incremental search
#   Ctrl + s       â†’ Forward search (may need `stty -ixon`)
#   Ctrl + g       â†’ Cancel search
#   Esc            â†’ Drop into prompt with matched command

# ğŸ§ª Example
#   $ echo hellp
#   $ ^hellp^hello   â†’ Corrects and reruns as: echo hello
#   $ !ls            â†’ Repeats last command starting with 'ls'

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


