#!/bin/bash
# Only apply strict mode in non-interactive shells
[[ $- != *i* ]] && set -euo pipefail


# set -x  # trace every command

# ─────────────────────────────────────────────
# Utility functions
# ─────────────────────────────────────────────

add_path_if_exists() {
    local position="$1" dir="$2"
    if [ -d "$dir" ] && [[ ":$PATH:" != *":$dir:"* ]]; then
        case "$position" in
        before) PATH="$dir:$PATH" ;;
        after) PATH="$PATH:$dir" ;;
        *) echo "Invalid position: $position (use 'before' or 'after')" >&2 ;;
        esac
    fi
}

# Lazy-load nvm (significant speed improvement)
nvm() {
    unset -f nvm
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    nvm "$@"
}

# Map of verified safe local commands
declare -A _RUN_LOCAL_SAFE_CACHE=()

run_local() {
    local cmd="$1"
    shift
    local local_cmd="$HOME/.local/bin/$cmd"

    # Check cache first
    if [[ "${_RUN_LOCAL_SAFE_CACHE[$cmd]-}" == "safe" ]]; then
        "$local_cmd" "$@" || {
            echo "⚠️ Command '$cmd' failed. Skipping." >&2
            return 0
        }
        return 0
    fi

    # First-time check
    if [ ! -x "$local_cmd" ]; then
        echo "⚠️ Command '$cmd' not found or not executable in $HOME/.local/bin. Skipping." >&2
        _RUN_LOCAL_SAFE_CACHE["$cmd"]="missing"
        return 0
    fi

    local resolved
    resolved="$(command -v "$cmd" 2>/dev/null || true)"
    if [ "$resolved" != "$local_cmd" ]; then
        echo "⚠️ Command '$cmd' is not resolved to $HOME/.local/bin first in PATH (resolved to $resolved). Skipping." >&2
        _RUN_LOCAL_SAFE_CACHE["$cmd"]="wrong_path"
        return 0
    fi

    # Safe → cache this fact
    _RUN_LOCAL_SAFE_CACHE["$cmd"]="safe"
    "$local_cmd" "$@" || {
        echo "⚠️ Command '$cmd' failed. Skipping." >&2
        return 0
    }
}

source_if_exists() {
    local file="$1"
    if [ -f "$file" ]; then
        # shellcheck source=/dev/null
        source "$file"
    fi
}

vcode() {
    local base_dir="${HOME}/projects"

    if [[ $# -eq 0 ]]; then
        echo "Usage: vcode [project1 project2 ...] or vcode --all"
        return 1
    fi

    if [[ $# -eq 1 && -f "${base_dir}/$1.code-workspace" ]]; then
        # Use existing named workspace file
        code "${base_dir}/$1.code-workspace"
        return
    fi

    # Else, build a temporary workspace file
    local tmp_workspace_dir="/tmp/vcode_workspace_$$"
    mkdir -p "$tmp_workspace_dir"
    local workspace_file="${tmp_workspace_dir}/workspace.code-workspace"

    local folders=()

    if [[ "$1" == "--all" ]]; then
        # Include all immediate subdirectories of ~/projects/
        while IFS= read -r -d '' dir; do
            folders+=("{\"path\": \"$dir\"}")
        done < <(find "$base_dir" -mindepth 1 -maxdepth 1 -type d -print0)

        if [[ ${#folders[@]} -eq 0 ]]; then
            echo "⚠️ No subdirectories found under $base_dir"
            return 1
        fi
    else
        # Manually specified projects
        for project in "$@"; do
            local dir="$base_dir/$project"
            if [[ ! -d "$dir" ]]; then
                echo "❌ '$project' does not exist in $base_dir"
                continue
            fi
            folders+=("{\"path\": \"$dir\"}")
        done

        if [[ ${#folders[@]} -eq 0 ]]; then
            echo "🚫 No valid projects to open"
            return 1
        fi
    fi

    # Write workspace JSON
    printf '{\n  "folders": [\n    %s\n  ]\n}\n' "$(
        IFS=,$'\n'
        echo "${folders[*]}"
    )" >"$workspace_file"

    code "$workspace_file"
}

# ─────────────────────────────────────────────
# Completions
# ─────────────────────────────────────────────

_vcode_autocomplete() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local project_dir="$HOME/projects"
    local projects

    # Only complete if not using --all
    if [[ "$COMP_CWORD" -ge 1 && "${COMP_WORDS[1]}" != --all ]]; then
        projects=$(find "$project_dir" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' 2>/dev/null)
        readarray -t COMPREPLY < <(compgen -W "$projects" -- "$cur")
    fi
}

# ─────────────────────────────────────────────
# Basic environment variables
# ─────────────────────────────────────────────

set -a

NVM_DIR="$HOME/.nvm"

IS_WSL=false
if grep -qi microsoft /proc/version; then
    IS_WSL=true
fi

if [ "$IS_WSL" = true ]; then
    if command -v cmd.exe >/dev/null 2>&1; then
        WINDOWS_USER=$(cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r')
    else
        WINDOWS_USER=""
    fi
    VSCODE_SETTINGS_DIR="/mnt/c/Users/$WINDOWS_USER/AppData/Roaming/Code/User"
else
    VSCODE_SETTINGS_DIR="$HOME/.config/Code/User"
fi

# ignore unused variable
# shellcheck disable=SC2034
VSCODE_SETTINGS_FILE="$VSCODE_SETTINGS_DIR/settings.json"

source_if_exists "$HOME/.env"

set +a

# ─────────────────────────────────────────────
# Execute commands
# ─────────────────────────────────────────────

complete -F _vcode_autocomplete vcode

add_path_if_exists before "$HOME/.local/bin"

# go used for hugo
add_path_if_exists after "/usr/local/go/bin"
add_path_if_exists after "$HOME/go/bin"

# focus-here is slow and should only run in a true login shell
if shopt -q login_shell; then
    run_local focus-here
    #nvm
fi

# ─────────────────────────────────────────────
# Aliases
# ─────────────────────────────────────────────

alias codehugo='code --profile "hugo-blog" ${GITHUB_PARENT}/hugo-blog.code-workspace'
alias codefin='code --profile "python-project" ${GITHUB_PARENT}/our-finances.code-workspace'
alias codepy='code --profile "python-projects"'

# ──────────────────────────────────────────────────────────────
# 🧠 Bash History Cheat Sheet – Rerun & Edit Previous Commands
# ──────────────────────────────────────────────────────────────
# 🔁 Rerun Commands
#   !!             → Rerun last command
#   !n             → Run command number n from `history`
#   !string        → Rerun last command starting with 'string'
#   !^             → First argument of previous command
#   !$             → Last argument of previous command

# ✏️ Modify and Reuse
#   ^old^new       → Replace first 'old' with 'new' in previous command
#   !!:s/old/new/  → Replace first 'old' with 'new'
#   !!:gs/old/new/ → Replace all 'old' with 'new'
#   !n:p           → Print command n without running it
#   fc             → Edit previous command in $EDITOR

# 🔍 History Search
#   Ctrl + r       → Reverse incremental search
#   Ctrl + s       → Forward search (may need `stty -ixon`)
#   Ctrl + g       → Cancel search
#   Esc            → Drop into prompt with matched command

# 🧪 Example
#   $ echo hellp
#   $ ^hellp^hello   → Corrects and reruns as: echo hello
#   $ !ls            → Repeats last command starting with 'ls'

# ──────────────────────────────────────────────────────────────

# set +x # Turn off trace
