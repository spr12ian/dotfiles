#!/usr/bin/env bash

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Environment variables
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
set_post_bashrc_environment() {
    set -a

    local env_file="$HOME/.env"

    # shellcheck source=/dev/null
    if [ -f "$env_file" ]; then
        source "$env_file"
    else
        echo "Missing .env file"
        return 1
    fi

    NVM_DIR="$HOME/.nvm"

    IS_WSL=false
    if grep -qi microsoft /proc/version; then
        IS_WSL=true
    fi

    if [ "$IS_WSL" = true ]; then
        if command -v cmd.exe >/dev/null 2>&1; then
            WINDOWS_USER=$(cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r')
        else
            WINDOWS_USER=""
        fi
        VSCODE_SETTINGS_DIR="/mnt/c/Users/$WINDOWS_USER/AppData/Roaming/Code/User"
    else
        VSCODE_SETTINGS_DIR="$HOME/.config/Code/User"
    fi

    # ignore unused variable
    # shellcheck disable=SC2034
    VSCODE_SETTINGS_FILE="$VSCODE_SETTINGS_DIR/settings.json"

    if declare -p GITHUB_PARENT &>/dev/null; then
        # shellcheck disable=SC2034
        VSCODE_WORKSPACE_DIR="$GITHUB_PARENT/my-vs-code/workspaces"
        # shellcheck disable=SC2034
        GITHUB_DOTFILES_DIR="$GITHUB_PARENT/dotfiles"
    else
        echo "âš ï¸ GITHUB_PARENT not set"
    fi

    SYMLINKS_BIN_DIR="$HOME/.symlinks/bin"

    set +a
}

if declare -F set_post_bashrc_environment >/dev/null; then
    if ! set_post_bashrc_environment; then
        echo "âŒ Environment setup failed"
        return 1
    fi
else
    echo "âš ï¸  set_post_bashrc_environment is not defined"
    return 1
fi

source_bash_functions() {
    # shellcheck disable=SC1091
    #source "$SYMLINKS_SOURCE_DIR/bash_functions"
    if [[ -n "${GITHUB_PARENT:-}" ]]; then
        local bf_file="$GITHUB_PARENT/bin/source/bash_functions.sh"

        # shellcheck source=/dev/null
        if [ -f "$bf_file" ]; then
            source "$bf_file"
        else
            echo "âš ï¸ Missing file: $bf_file"
            return 1
        fi
    else
        echo "âš ï¸ GITHUB_PARENT not set â€“ skipping bash_functions.sh"
    fi
}
source_bash_functions

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Utility functions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

#!/usr/bin/env bash
# command_utils.sh â€” Bash module for command checks and path resolution

# Prevent double-sourcing
if [[ -n "${__COMMAND_UTILS_LOADED:-}" ]]; then return 0; fi
__COMMAND_UTILS_LOADED=1

# Optional debug logging
_log_debug() {
    [[ "${DEBUG:-}" =~ ^(1|true|TRUE)$ ]] && echo "DEBUG: $*" >&2
}

finish_dotfile_test() {
    local name="$1"
    local sources=("${BASH_SOURCE[@]:1}") # Skip this function itself
    echo -e "finish_dotfile_test started at: $(date)"
    (
        IFS=' '
        echo "This script           : ${sources[0]}"
    )
    echo -e "\$name=$name"
    echo -e "\$TEST_DOTFILE_NAME=$TEST_DOTFILE_NAME"
    echo -e "finish_dotfile_test finished at: $(date)"
    if [[ "$name" == "$TEST_DOTFILE_NAME" ]]; then
        echo -e "ğŸ›‘ Exiting"
        exit
    fi
}

# Detect if we're being run as part of VS Code's userEnvProbe
is_user_env_probe() {
    ps -eo pid,ppid,args | awk '
        NR > 1 {
            pid[$1] = $2
            cmd[$1] = substr($0, index($0,$3))
        }
        END {
            p = ENVIRON["PPID"]
            while (p > 1) {
                if (cmd[p] ~ /userEnvProbe/) exit 0
                p = pid[p]
            }
            exit 1
        }
    '
}

# Lazy-load nvm (significant speed improvement)
nvm() {
    unset -f nvm
    # shellcheck disable=SC1091
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    # shellcheck disable=SC1091
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    nvm "$@"
}

remove_path() {
    local remove="$1"
    PATH=$(echo "$PATH" | tr ':' '\n' | grep -v -x "$remove" | paste -sd:)
}

# Map of verified safe local commands
declare -A _RUN_LOCAL_SAFE_CACHE=()

run_local() {
    local cmd="$1"
    shift
    local local_cmd="$SYMLINKS_BIN_DIR/$cmd"

    # Check cache first
    if [[ "${_RUN_LOCAL_SAFE_CACHE[$cmd]-}" == "safe" ]]; then
        "$local_cmd" "$@" || {
            echo "âš ï¸ Command '$cmd' failed. Skipping." >&2
            return 0
        }
        return 0
    fi

    # First-time check
    if [ ! -x "$local_cmd" ]; then
        echo "âš ï¸ Command '$cmd' not found or not executable in $SYMLINKS_BIN_DIR. Skipping." >&2
        _RUN_LOCAL_SAFE_CACHE["$cmd"]="missing"
        return 0
    fi

    local resolved
    resolved="$(command -v "$cmd" 2>/dev/null || true)"
    if [ "$resolved" != "$local_cmd" ]; then
        echo "âš ï¸ Command '$cmd' is not resolved to $SYMLINKS_BIN_DIR first in PATH (resolved to $resolved). Skipping." >&2
        _RUN_LOCAL_SAFE_CACHE["$cmd"]="wrong_path"
        return 0
    fi

    # Safe â†’ cache this fact
    _RUN_LOCAL_SAFE_CACHE["$cmd"]="safe"
    "$local_cmd" "$@" || {
        echo "âš ï¸ Command '$cmd' failed. Skipping." >&2
        return 0
    }
}

start_dotfile_test() {
    echo "start_dotfile_test started at: $(date)"

    echo -e "\$TEST_DOTFILE_NAME=$TEST_DOTFILE_NAME"

    local sources=("${BASH_SOURCE[@]:1}") # Skip this function itself

    echo "Shell type           : $0"
    echo "Bash version         : $BASH_VERSION"
    (
        IFS=' '
        echo "Call stack           : ${sources[*]}"
    )
    echo "Current options (\$-): $-"

    echo -n "Is interactive?      : [[ \$- == *i* ]] â†’ "
    [[ $- == *i* ]] && echo yes || echo no

    echo -n "Is login shell?      : shopt -q login_shell â†’ "
    shopt -q login_shell && echo yes || echo no

    echo -n "PS1 set?             : declare -p PS1 &>/dev/null â†’ "
    declare -p PS1 &>/dev/null && echo yes || echo no

    echo "TERM_PROGRAM         : ${TERM_PROGRAM:-}"
    echo "Host                 : $(hostname -f 2>/dev/null || hostname)"
    echo "Shell PID            : $$"

    # More portable parent process command
    local parent_pid parent_cmd
    parent_pid=$(ps -o ppid= -p $$ 2>/dev/null)
    parent_cmd=$(ps -o comm= -p "$parent_pid" 2>/dev/null || echo unknown)
    echo "Parent process       : ${parent_cmd}"

    echo "TTY                  : $(tty 2>/dev/null || echo not-a-tty)"

    echo -e "\n--- Environment Variables ---"
    env | sort
    echo -e "\n--- Aliases ---"
    alias
    echo -e "\n--- Functions ---"
    compgen -A function
    echo -e "\n--- start_dotfile_test finished at: $(date)\n"
}

source_if_exists() {
    local file="$1"
    if [ -f "$file" ]; then
        # shellcheck source=/dev/null
        source "$file"
    fi
}

_vcode_autocomplete() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local project_dir="$HOME/projects"
    local projects

    # Only complete if not using --all
    if [[ "$COMP_CWORD" -ge 1 && "${COMP_WORDS[1]}" != --all ]]; then
        projects=$(find "$project_dir" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' 2>/dev/null)
        readarray -t COMPREPLY < <(compgen -W "$projects" -- "$cur")
    fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Completions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

complete -F _vcode_autocomplete vcode

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# PATH
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

remove_path "/usr/games"
remove_path "/usr/local/games"

# before

add_path_if_exists before "$SYMLINKS_BIN_DIR"

#after

# go used for hugo
add_path_if_exists after \
    "/mnt/c/Program Files/Microsoft VS Code/bin" \
    "/usr/local/go/bin" \
    "$HOME/go/bin"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Aliases
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if [[ $- == *i* ]]; then
    # We are in an interactive shell
    alias test_bash_functions='source "$HOME/.symlinks/source/test_bash_functions" &>/tmp/test_bash_functions.log'
    alias testlogin='ssh -i ~/.ssh/id_ed25519_testuser testuser@localhost'
fi

declare -p TEST_DOTFILE_NAME &>/dev/null && start_dotfile_test && finish_dotfile_test post_bashrc
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ§  Bash History Cheat Sheet â€“ Rerun & Edit Previous Commands
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ” Rerun Commands
#   !!             â†’ Rerun last command
#   !n             â†’ Run command number n from `history`
#   !string        â†’ Rerun last command starting with 'string'
#   !^             â†’ First argument of previous command
#   !$             â†’ Last argument of previous command

# âœï¸ Modify and Reuse
#   ^old^new       â†’ Replace first 'old' with 'new' in previous command
#   !!:s/old/new/  â†’ Replace first 'old' with 'new'
#   !!:gs/old/new/ â†’ Replace all 'old' with 'new'
#   !n:p           â†’ Print command n without running it
#   fc             â†’ Edit previous command in $EDITOR

# ğŸ” History Search
#   Ctrl + r       â†’ Reverse incremental search
#   Ctrl + s       â†’ Forward search (may need `stty -ixon`)
#   Ctrl + g       â†’ Cancel search
#   Esc            â†’ Drop into prompt with matched command

# ğŸ§ª Example
#   $ echo hellp
#   $ ^hellp^hello   â†’ Corrects and reruns as: echo hello
#   $ !ls            â†’ Repeats last command starting with 'ls'

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
